---
layout:     post
title:      Docker
date:       2019-10-01
author:     BenderFly
header-img: img/post-bg-coffee.jpeg
catalog: true
categories: Docker
tags:
    - Docker
---

# 配置 Docker 镜像加速国内加速站点
```
vim /etc/docker/daemon.json
{
"insecure-registries":["主机的IP地址或者域名:5000"],
"registry-mirrors": ["https://registry.docker-cn.com"]
}

https://registry.docker-cn.com
http://hub-mirror.c.163.com
https://3laho3y3.mirror.aliyuncs.com
http://f1361db2.m.daocloud.io
https://mirror.ccs.tencentyun.com
```
# 查看docker信息
```
docker version :查看版本
docker info : 显示 Docker 系统信息，包括镜像和容器数。
```

# 容器
运行容器
```
docker run --restart=always redis  # --estart 容器退出时自动重启,默认no
docker run --restart=on-failure:10 redis # 非零退出转态,重试10次
```

```
docker create  --name my_container  nginx:latest     #创建一个新的容器但不启动它
docker start my_container# 启动一个或多个已经被停止的容器
docker stop my_container#停止一个运行中的容器
docker restart my_container#重启容器
docker kill -s KILL mynginx #杀掉运行中的容器mynginx

docker rm #删除一个或多少容器
docker rm -f db01 db02  # 强制删除容器db01、db02
docker rm -l db         # 移除容器nginx01对容器db01的连接，连接名db
docker rm -v nginx01    # 删除容器nginx01,并删除容器挂载的数据卷
docker container prune  # 清理掉所有处于终止状态的容器

docker pause db01:暂停容器中所有的进程。
docker unpause db01:恢复容器中所有的进程。
```

查看容器信息
```
docker container ls
docker container ls -a
docker ps
docker ps -a   #显示所有的容器，包括未运行的。
```
要获取容器的输出信息
```
docker container logs
docker container logs [container ID or NAMES]查看容器信息
```

要获取容器的输出信息
```
docker container logs
docker container logs [container ID or NAMES]查看容器信息

docker logs -f mynginx  # -f : 跟踪日志输出
docker logs --since="2016-07-01" --tail=10 mynginx  # --since :显示某个开始时间的所有日志 --tail :仅列出最新N条容器日志
```
获取容器/镜像的元数据
```
docker inspect mysql:5.6
```
查看容器中运行的进程信息
```
docker container top 262242feaa88
```
列出指定的容器的端口映射
```
docker port mymysql  #查看容器mynginx的端口映射情况。
```
检查容器里文件结构的更改
```
docker diff mymysql
```
进入容器
```
docker attach 命令 (exit会导致容器的停止)
docker exec 命令(推荐使用)
docker exec -it 69d1 bash
```

容器与主机之间的数据拷贝
```
docker cp /www/runoob 96f7f14e99ab:/www/ # 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。
docker cp /www/runoob 96f7f14e99ab:/www  # 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。
docker cp  96f7f14e99ab:/www /tmp/       # 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。
```

# docker搭建本地私有仓库
1.拉取镜像仓库
```
docker pull registry 
```
2.启动镜像服务器registry
首先在在主机上新建一个目录，供存储镜像
```
cd /usr/local/
mkdir docker_registry 
````
启动镜像
```
docker run -d -p 5000:5000 --name=jackspeedregistry --restart=always --privileged=true  -v /usr/local/docker_registry:/var/lib/registry  docker.io/registry
```
解释
```
--privileged=true centos7中的安全模块selinux把权限禁止了, 加上这行是给容器增加执行权限
-v /usr/local/docker_registry:/var/lib/registry 把主机的/usr/local/docker_registry 目录挂载到registry容器的/var/lib/registry目录下,假如有删除容器操作,我们的镜像也不会被删除
```
3.从公有仓库拉取一个镜像下来,然后push到私有仓库中进行测试
当前用nginx镜像做测试
```
docker pull  nginx 
docker images 
```
4.给docker注册https协议,支持https访问
```
vim /etc/docker/daemon.json
{
"insecure-registries":["主机的IP地址或者域名:5000"],
"registry-mirrors": ["https://registry.docker-cn.com"]
}
注释:
insecure-registries--->开放注册https协议   # Docker 默认不允许非 HTTPS 方式推送镜像。所以要配置insecure-registries
registry-mirrors--->仓库源
```
5.新建一个tag,把docker.io/nginx名称变成域名或者IP/镜像名称
```
docker tag docker.io/nginx ip或者域名:5000/nginx
```
推送到本地仓库
```
docker push ip或者域名:5000/nginx 
```
6.用 curl 查看仓库中的镜像。
````
$ curl 127.0.0.1:5000/v2/_catalog
{"repositories":["ubuntu"]}
````
7.删除刚刚tag的镜像 （11.*****:5000/nginx刚才创建的镜像的tag）
```
docker rmi 111.*****:5000/nginx
docker rmi  nginx 
```
8.拉取刚刚自己创建的镜像
```
docker pull 111.*****:5000/nginx
```

# login/logout
docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub
docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub

登陆到Docker Hub
```
docker login localhost:8080
docker login -u 用户名 -p 密码
cat ~/my_password.txt | docker login --username foo --password-stdin

--username , -u	:登陆的用户名
--password , -p :登陆的密码
--password-stdin :从标准输入password
登出Docker Hub
docker logout
```

# 仓库
```
docker pull : 从镜像仓库中拉取或者更新指定镜像
docker pull java

docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库
docker push myapache:v1

docker search : 从Docker Hub查找镜像
docker search -s 10 java #从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像
```

# 数据卷管理
```
-v或--volume：由三个字段组成，以冒号（:）分隔
第一个字段是卷的名称,对于匿名卷，将省略第一个字段。
第二个字段是文件或目录在容器中的安装路径。
第三个字段是可选的，并且是逗号分隔的选项列表，例如ro

--mount：包含多个键值对,<key>=<value>，以逗号分隔
type:        可以是bind，volume，或 tmpfs。
source:      这是卷的名称。对于匿名卷，将省略此字段。可以指定为source 或src。
destination: 容器内的挂载路径。可以指定为destination，dst或target。
readonly:   （如果存在）会使绑定安装以只读方式安装到容器中。
volume-opt:  可以多次指定的选项采用键值对。
```
创建和管理卷
创建卷
```
docker volume create my-vol
```
查看卷
```
docker volume ls
docker volume inspect my-vol
````
删除卷
```
docker volume rm my-vol
```
默认为type为volume,不存在则会创建volume
```
$ docker run -d --name devtest --mount source=myvol2,target=/app  nginx:latest
$ docker run -d --name devtest -v myvol2:/app nginx:latest

$ docker run -d --name=nginxtest --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly nginx:latest
$ docker run -d --name=nginxtest -v nginx-vol:/usr/share/nginx/html:ro nginx:latest
```
查看
```
docker inspect devtest
```
创建一个创建NFS卷的服务
```
NFSV3
docker service create -d --name nfs-service --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10'  nginx:latest

NFSV4
docker service create -d --name nfs-service  --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/,"volume-opt=o=10.0.0.10,rw,nfsvers=4,async"' nginx:latest
```
volume共享
```
docker run -it -v /opt/dbdata --name dbdata test/mycentos:v1.0 /bin/bash        # 在/opt/dbdata目录下创建文件db.properties
docker run -it --name vol_a --volumes-from dbdata test/mycentos:v1.0 /bin/bash  # vol_a,vol_b容器的/opt/dbdata下都有db.properties文件。
docker run -it --name vol_b --volumes-from vol_a test/mycentos:v1.0 /bin/bash   # 在vol_b的/opt/dbdata下创建文件vol_b.txt时，容器dbdata,vol_a也都同时同步了。
```
可以使用多个--volumes-from
```
docker run -it --name vol_use --volumes-from vol_a --volumes-from vol_b test/mycentos:v1.0 /bin/bash # vol_a
```

删除匿名的volume:
```
docker run --rm -v /foo -v awesome:/bar busybox top # --rm当容器删除时删除/foo,但是保留awesome(非匿名)
```
删除所有未使用的volume,并释放磁盘
```
docker volume prune
```
备份
```
docker run -v /dbdata --name dbstore ubuntu /bin/bash
docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata  # 备份到/backup目录下的backup.tar
```
恢复
```
docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c "tar xvf /backup/backup.tar -C /dbdata --strip=1" #strip删掉一级目录
```

# 导入导出
```
docker save : 将指定镜像保存成 tar 归档文件。
docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3  #将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档
-o :输出到的文件。

docker load : 导入使用 docker save 命令导出的镜像。
docker load < busybox.tar.gz
docker load --input fedora.tar
--input , -i : 指定导入的文件，代替 STDIN

docker export :将文件系统作为一个tar归档文件导出到STDOUT。
docker export -o mysql-`date +%Y%m%d`.tar a404c6c174a2  #将id为a404c6c174a2的容器按日期保存为tar文件。
-o :将输入内容写到文件 

docker import : 从归档文件中创建镜像。
docker import  my_ubuntu_v3.tar runoob/ubuntu:v4   #从镜像归档文件my_ubuntu_v3.tar创建镜像，命名为runoob/ubuntu:v4

save和export区别
docker save images_name：将一个镜像导出为文件，再使用docker load命令将文件导入为一个镜像，会保存该镜像的的所有历史记录。比docker export命令导出的文件大，因为会保存镜像的所有历史记录。
docker export container_id：将一个容器导出为文件，再使用docker import命令将容器导入成为一个新的镜像，但是相比docker save命令，容器文件会丢失所有元数据和历史记录，仅保存容器当时的状态，相当于虚拟机快照。
```


# 网络链接
```
--rm  # 退出时删除容器
--name my-redis # 指定名称
--network="bridge" # 指定网络
$ docker network create -d bridge my-net    # -d 指定网络类型
$ docker run --network=my-net -itd --name=container3 busybox  # --rm退出时删除容器
--name my-redis # 指定名称
--network="bridge" # 指定网络
$ docker network create -d bridge my-net
$ docker run --network=my-net -itd --name=container3 busybox
```














![getopts](https://raw.githubusercontent.com/handerfly/handerfly.github.io/master/img/getopt.png)  

[私有仓库](https://docs.docker.com/registry/deploying/)
[docker-compose](https://docs.docker.com/compose/compose-file/#configs)