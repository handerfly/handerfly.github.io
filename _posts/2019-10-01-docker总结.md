---
layout:     post
title:      Docker
date:       2019-10-01
author:     BenderFly
header-img: img/post-bg-coffee.jpeg
catalog: true
categories: Docker
tags:
    - Docker
---

# 配置 Docker 镜像加速国内加速站点
```
vim /etc/docker/daemon.json
{
"insecure-registries":["主机的IP地址或者域名:5000"],
"registry-mirrors": ["https://registry.docker-cn.com"]
}

https://registry.docker-cn.com
http://hub-mirror.c.163.com
https://3laho3y3.mirror.aliyuncs.com
http://f1361db2.m.daocloud.io
https://mirror.ccs.tencentyun.com
```

# docker搭建本地私有仓库
1.拉取镜像仓库
```
docker pull registry 
```
2.启动镜像服务器registry
首先在在主机上新建一个目录，供存储镜像
```
cd /usr/local/
mkdir docker_registry 
````
启动镜像
```
docker run -d -p 5000:5000 --name=jackspeedregistry --restart=always --privileged=true  -v /usr/local/docker_registry:/var/lib/registry  docker.io/registry
```
解释
```
--privileged=true centos7中的安全模块selinux把权限禁止了, 加上这行是给容器增加执行权限
-v /usr/local/docker_registry:/var/lib/registry 把主机的/usr/local/docker_registry 目录挂载到registry容器的/var/lib/registry目录下,假如有删除容器操作,我们的镜像也不会被删除
```
3.从公有仓库拉取一个镜像下来,然后push到私有仓库中进行测试
当前用nginx镜像做测试
```
docker pull  nginx 
docker images 
```
4.给docker注册https协议,支持https访问
```
vim /etc/docker/daemon.json
{
"insecure-registries":["主机的IP地址或者域名:5000"],
"registry-mirrors": ["https://registry.docker-cn.com"]
}
注释:
insecure-registries--->开放注册https协议   # Docker 默认不允许非 HTTPS 方式推送镜像。所以要配置insecure-registries
registry-mirrors--->仓库源
```
5.新建一个tag,把docker.io/nginx名称变成域名或者IP/镜像名称
```
docker tag docker.io/nginx ip或者域名:5000/nginx
```
推送到本地仓库
```
docker push ip或者域名:5000/nginx 
```
6.用 curl 查看仓库中的镜像。
````
$ curl 127.0.0.1:5000/v2/_catalog
{"repositories":["ubuntu"]}
````
7.删除刚刚tag的镜像 （11.*****:5000/nginx刚才创建的镜像的tag）
```
docker rmi 111.*****:5000/nginx
docker rmi  nginx 
```
8.拉取刚刚自己创建的镜像
```
docker pull 111.*****:5000/nginx
```

# login/logout
docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub
docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub

登陆到Docker Hub
```
docker login localhost:8080
docker login -u 用户名 -p 密码
cat ~/my_password.txt | docker login --username foo --password-stdin

--username , -u	:登陆的用户名
--password , -p :登陆的密码
--password-stdin :从标准输入password
登出Docker Hub
docker logout
```

# 仓库
```
docker pull : 从镜像仓库中拉取或者更新指定镜像
docker pull java

docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库
docker push myapache:v1

docker search : 从Docker Hub查找镜像
docker search -s 10 java #从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像
```

# 数据卷管理
```
-v或--volume：由三个字段组成，以冒号（:）分隔
第一个字段是卷的名称,对于匿名卷，将省略第一个字段。
第二个字段是文件或目录在容器中的安装路径。
第三个字段是可选的，并且是逗号分隔的选项列表，例如ro

--mount：包含多个键值对,<key>=<value>，以逗号分隔
type:        可以是bind，volume，或 tmpfs。
source:      这是卷的名称。对于匿名卷，将省略此字段。可以指定为source 或src。
destination: 容器内的挂载路径。可以指定为destination，dst或target。
readonly:   （如果存在）会使绑定安装以只读方式安装到容器中。
volume-opt:  可以多次指定的选项采用键值对。
```
创建和管理卷
创建卷
```
docker volume create my-vol
```
查看卷
```
docker volume ls
docker volume inspect my-vol
````
删除卷
```
docker volume rm my-vol
```
默认为type为volume,不存在则会创建volume
```
$ docker run -d --name devtest --mount source=myvol2,target=/app  nginx:latest
$ docker run -d --name devtest -v myvol2:/app nginx:latest

$ docker run -d --name=nginxtest --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly nginx:latest
$ docker run -d --name=nginxtest -v nginx-vol:/usr/share/nginx/html:ro nginx:latest
```
查看
```
docker inspect devtest
```
创建一个创建NFS卷的服务
```
NFSV3
docker service create -d --name nfs-service --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10'  nginx:latest

NFSV4
docker service create -d --name nfs-service  --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/,"volume-opt=o=10.0.0.10,rw,nfsvers=4,async"' nginx:latest
```
volume共享
```
docker run -it -v /opt/dbdata --name dbdata test/mycentos:v1.0 /bin/bash        # 在/opt/dbdata目录下创建文件db.properties
docker run -it --name vol_a --volumes-from dbdata test/mycentos:v1.0 /bin/bash  # vol_a,vol_b容器的/opt/dbdata下都有db.properties文件。
docker run -it --name vol_b --volumes-from vol_a test/mycentos:v1.0 /bin/bash   # 在vol_b的/opt/dbdata下创建文件vol_b.txt时，容器dbdata,vol_a也都同时同步了。
```
可以使用多个--volumes-from
```
docker run -it --name vol_use --volumes-from vol_a --volumes-from vol_b test/mycentos:v1.0 /bin/bash # vol_a
```

删除匿名的volume:
```
docker run --rm -v /foo -v awesome:/bar busybox top # --rm当容器删除时删除/foo,但是保留awesome(非匿名)
```
删除所有未使用的volume,并释放磁盘
```
docker volume prune
```
备份
```
docker run -v /dbdata --name dbstore ubuntu /bin/bash
docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata  # 备份到/backup目录下的backup.tar
```
恢复
```
docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c "tar xvf /backup/backup.tar -C /dbdata --strip=1" #strip删掉一级目录
```


# 网络链接
```
--rm  # 退出时删除容器
--name my-redis # 指定名称
--network="bridge" # 指定网络
$ docker network create -d bridge my-net    # -d 指定网络类型
$ docker run --network=my-net -itd --name=container3 busybox  # --rm退出时删除容器
--name my-redis # 指定名称
--network="bridge" # 指定网络
$ docker network create -d bridge my-net
$ docker run --network=my-net -itd --name=container3 busybox
```














![getopts](https://raw.githubusercontent.com/handerfly/handerfly.github.io/master/img/getopt.png)  

[私有仓库](https://docs.docker.com/registry/deploying/)
[docker-compose](https://docs.docker.com/compose/compose-file/#configs)