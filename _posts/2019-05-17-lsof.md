---
layout:     post
title:      lsof
date:       2019-05-17
author:     BenderFly
header-img: img/post-bg-coffee.jpeg
catalog: true
categories: 运维
tags: 运维
---

# lsof常用参数
lsof语法格式是： lsof ［options］ filename
```

lsof -a             表示两个参数都必须满足时才显示结果
lsof -c -p 1234     列出进程号为1234的进程所打开的文件 
lsof -c string      显示COMMAND列中包含指定字符的进程所有打开的文件
lsof -u username    显示所属user进程打开的文件
lsof -g gid 		显示归属gid的进程情况 
lsof +d /usr/local/ 显示目录下被进程开启的文件 
lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长 
lsof -d 4 			显示使用fd为4的进程 
lsof -d FD          显示指定文件描述符的进程
lsof -n          不将IP转换为hostname，缺省是不加上-n参数
lsof -i 			用以显示符合条件的进程情况 
lsof -i[46] [protocol][@hostname|hostaddr][:service|port]   

46 --> IPv4 or IPv6
protocol --> TCP or UDP
hostname --> Internet host name
hostaddr --> IPv4位置
service --> /etc/service中的 service name (可以不只一个)
port --> 端口号 (可以不只一个)

```
# lsof使用实例
查找谁在使用文件系统

在卸载文件系统时，如果该文件系统中有任何打开的文件，操作通常将会失败。那么通过lsof可以找出那些进程在使用当前要卸载的文件系统，
如下： 
```
# lsof /GTES11/ 
COMMAND PID   USER FD   TYPE   DEVICE  SIZE NODE NAME 
bash    4208  root cwd   DIR     3,1   4096  2  /GTES11/ 
vim     4230  root cwd   DIR     3,1   4096  2 /GTES11/ 
```
在这个示例中，用户root正在其/GTES11目录中进行一些操作。一个 bash是实例正在运行，并且它当前的目录为/GTES11，另一个则显示的是vim正在编辑/GTES11下的文件。要成功地卸载/GTES11，应该在通知用户以确保情况正常之后，中止这些进程。 
这个示例说明了应用程序的当前工作目录非常重要，因为它仍保持着文件资源，并且可以防止文件系统被卸载。
这就是为什么大部分守护进程（后台进程）将它们的目录更改为根目录、或服务特定的目录（如 sendmail 示例中的 /var/spool/mqueue）的原因，以避免该守护进程阻止卸载不相关的文件系统。

 

# 恢复删除的文件

当Linux计算机受到入侵时，常见的情况是日志文件被删除，以掩盖攻击者的踪迹。管理错误也可能导致意外删除重要的文件，比如在清理旧日志时，意外地删除了数据库的活动事务日志。有时可以通过lsof来恢复这些文件。 
当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。
除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。 在/proc 目录下，其中包含了反映内核和进程树的各种文件。
/proc目录挂载的是在内存中所映射的一块区域，所以这些文件和目录并不存在于磁盘中，因此当我们对这些文件进行读取和写入时，实际上是在从内存中获取相关信息。
大多数与 lsof 相关的信息都存储于以进程的 PID 命名的目录中，即 /proc/1234 中包含的是 PID 为 1234 的进程的信息。
每个进程目录中存在着各种文件，它们可以使得应用程序简单地了解进程的内存空间、文件描述符列表、指向磁盘上的文件的符号链接和其他系统信息。
lsof 程序使用该信息和其他关于内核内部状态的信息来产生其输出。所以lsof 可以显示进程的文件描述符和相关的文件名等信息。也就是我们通过访问进程的文件描述符可以找到该文件的相关信息。 
当系统中的某个文件被意外地删除了，只要这个时候系统中还有进程正在访问该文件，那么我们就可以通过lsof从/proc目录下恢复该文件的内容。 
假如由于误操作将/var/log/messages文件删除掉了，那么这时要将/var/log/messages文件恢复的方法如下： 
首先使用lsof来查看当前是否有进程打开/var/logmessages文件，
如下： 
```
# lsof |grep /var/log/messages 
syslogd 1283 root 2w REG 3,3 5381017 1773647 /var/log/messages (deleted) 
```
从上面的信息可以看到 PID 1283（syslogd）打开文件的文件描述符为 2。同时还可以看到/var/log/messages已经标记被删除了。因此我们可以在 /proc/1283/fd/2 （fd下的每个以数字命名的文件表示进程对应的文件描述符）中查看相应的信息，
如下： 
```
# head -n 10 /proc/1283/fd/2 
Aug 4 13:50:15 holmes86 syslogd 1.4.1: restart. Aug 4 13:50:15 holmes86 kernel: klogd 1.4.1, log source = /proc/kmsg started. 
Aug 4 13:50:15 holmes86 kernel: Linux version 2.6.22.1-8 (root@everestbuilder.linux-ren.org) (gcc version 4.2.0) #1 SMP Wed Jul 18 11:18:32 EDT 2007 
Aug 4 13:50:15 holmes86 kernel: BIOS-provided physical RAM map: 
Aug 4 13:50:15 holmes86 kernel: BIOS-e820: 0000000000000000 - 000000000009f000 (usable) 
Aug 4 13:50:15 holmes86 kernel: BIOS-e820: 000000000009f000 - 00000000000a0000 (reserved) 
Aug 4 13:50:15 holmes86 kernel: BIOS-e820: 0000000000100000 - 000000001f7d3800 (usable) 
Aug 4 13:50:15 holmes86 kernel: BIOS-e820: 000000001f7d3800 - 0000000020000000 (reserved) 
Aug 4 13:50:15 holmes86 kernel: BIOS-e820: 00000000e0000000 - 00000000f0007000 (reserved) 
Aug 4 13:50:15 holmes86 kernel: BIOS-e820: 00000000f0008000 - 00000000f000c000 (reserved) 
```
从上面的信息可以看出，查看 /proc/8663/fd/15 就可以得到所要恢复的数据。如果可以通过文件描述符查看相应的数据，那么就可以使用 I/O 重定向将其复制到文件中，
如: cat /proc/1283/fd/2 > /var/log/messages 对于许多应用程序，尤其是日志文件和数据库，这种恢复删除文件的方法非常有用。

 

可以列出被进程所打开的文件的信息。被打开的文件可以是
1.普通的文件，
2.目录  
3.网络文件系统的文件，
4.字符设备文件  
5.(函数)共享库  
6.管道，命名管道 
7.符号链接
8.底层的socket字流，网络socket，unix域名socket
9.在linux里面，大部分的东西都是被当做文件的…..还有其他很多

# 怎样使用lsof

这里主要用案例的形式来介绍lsof 命令的使用

1.列出所有打开的文件:
```
lsof
```
备注: 如果不加任何参数，就会打开所有被打开的文件，建议加上一下参数来具体定位

2. 查看谁正在使用某个文件
```
lsof   /filepath/file
```
3.递归查看某个目录的文件信息
```
lsof +D /filepath/filepath2/
```
备注: 使用了+D，对应目录下的所有子目录和文件都会被列出

4. 比使用+D选项，遍历查看某个目录的所有文件信息 的方法
```
lsof | grep ‘/filepath/filepath2/’
```
5. 列出某个用户打开的文件信息
```
lsof  -u username
```
备注: -u 选项，u其实是user的缩写

6. 列出某个程序所打开的文件信息
```
lsof -c mysql
```
备注: -c 选项将会列出所有以mysql开头的程序的文件，其实你也可以写成lsof | grep mysql,但是第一种方法明显比第二种方法要少打几个字符了

7. 列出多个程序多打开的文件信息
```
lsof -c mysql -c apache
```
8. 列出某个用户以及某个程序所打开的文件信息
```
lsof -u test -c mysql
```
9. 列出除了某个用户外的被打开的文件信息
```
lsof   -u ^root
```
备注：^这个符号在用户名之前，将会把是root用户打开的进程不让显示

10. 通过某个进程号显示该进行打开的文件
```
lsof -p 1
```
11. 列出多个进程号对应的文件信息
```
lsof -p 123,456,789
```
12. 列出除了某个进程号，其他进程号所打开的文件信息
```
lsof -p ^1
```
13 . 列出所有的网络连接
```
lsof -i
```
14. 列出所有tcp 网络连接信息
```
lsof  -i tcp
```
15. 列出所有udp网络连接信息
```
lsof  -i udp
```
16. 列出谁在使用某个端口
```
lsof -i :3306
```
17. 列出谁在使用某个特定的udp端口
```
lsof -i udp:55
```
特定的tcp端口
```
lsof -i tcp:80
```
18. 列出某个用户的所有活跃的网络端口
```
lsof  -a -u test -i
```
19. 列出所有网络文件系统
```
lsof -N
```
20.域名socket文件
```
lsof -u
```
21.某个用户组所打开的文件信息
```
lsof -g 5555
```
22. 根据文件描述列出对应的文件信息
```
lsof -d description(like 2)
```
23. 根据文件描述范围列出文件信息
```
lsof -d 2-3
```

# 实用命令
```
lsof `which httpd` //那个进程在使用apache的可执行文件 
lsof /etc/passwd //那个进程在占用/etc/passwd 
lsof /dev/hda6 //那个进程在占用hda6 
lsof /dev/cdrom //那个进程在占用光驱 
lsof -c sendmail //查看sendmail进程的文件使用情况 
lsof -c courier -u ^zahn //显示出那些文件被以courier打头的进程打开，但是并不属于用户zahn 
lsof -p 30297 //显示那些文件被pid为30297的进程打开 
lsof -D /tmp 显示所有在/tmp文件夹中打开的instance和文件的进程。但是symbol文件并不在列
lsof -u1000 //查看uid是100的用户的进程的文件使用情况 
lsof -utony //查看用户tony的进程的文件使用情况 
lsof -u^tony //查看不是用户tony的进程的文件使用情况(^是取反的意思) 
lsof -i //显示所有打开的端口 
lsof -i:80 //显示所有打开80端口的进程 
lsof -i -U //显示所有打开的端口和UNIX domain文件 
lsof -i UDP@[url]www.akadia.com:123 //显示那些进程打开了到www.akadia.com的UDP的123(ntp)端口的链接 
lsof -i tcp@ohaha.ks.edu.tw:ftp -r //不断查看目前ftp连接的情况(-r，lsof会永远不断的执行，直到收到中断信号,+r，lsof会一直执行，直到没有档案被显示,缺省是15s刷新) 
lsof -i tcp@ohaha.ks.edu.tw:ftp -n //lsof -n 不将IP转换为hostname，缺省是不加上-n参数

```
