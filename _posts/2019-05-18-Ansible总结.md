---
layout:     post
title:      Ansible总结
date:       2019-05-18
author:     BenderFly
header-img: img/post-bg-coffee.jpeg
catalog: true
categories: 运维
tags:
    - Ansible
    - 运维
---

# Ansible总结

## 安装ansible
```
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
yum install -y ansible
```
## 查看ansible生成的文件
```
rpm -ql ansible|more
```

配置ssh免密码登录
```
ssh-keygen
ssh-copy-id 192.168.107.131 # 复制秘钥到远程主机
ssh-copy-id -i /root/.ssh/id_rsa.pub root@10.1.1.60 # -i指定公钥文件
```
# 查看帮助文档
```
## ansible-doc -h 
ansible-doc -l 			   # 查看所有模块
ansible-doc -s module-name # 查看模块使用方法(显示片段)
ansible-doc module-name    # 查看模块使用方法(更具体)
```

# ansible命令参数
```
语法: ansible<host-pattern> [-f forks] [-m module_name] [-a args] 
ansible -h     命令格式查看

-v,–verbose    			 			# 细模式，如果命令执行成功，输出详细的结果 (-vv –vvv -vvvv)
-i PATH,–inventory=PATH  			# 指定 host 文件的路径，默认是在 /etc/ansible/hosts
-f NUM,–forks=NUM 		 			# NUM 是指定一个整数，默认是 5 ，指定 fork 开启同步进程的个数。用来做高并发的
-m NAME,–module-name=NAME			# 指定使用的 module 名称，默认是 command
-m DIRECTORY,–module-path=DIRECTORY # 指定 module 的目录来加载 module ，默认是/usr/share/ansible,
-a MODULE_ARGS, --args=MODULE_ARGS  # 指定 module 模块的参数
-k,–ask-pass						# 提示输入 ssh 的密码，而不是使用基于 ssh 的密钥认证
–sudo								# 指定使用 sudo 获得 root 权限
-K,–ask-sudo-pass   				# 提示输入 sudo 密码，与 –sudo 一起使用
-u USERNAME,–user=USERNAME  		# 指定移动端的执行用户
-C,–check                           # 测试此命令执行会改变什么内容，不会真正的去执行
--list-hosts #列出主机列表
--syntax-check # 语法检查
```


# YAML基本语法
> YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用"-"来代表，Map里的键值对用":"分隔。

YAML文件扩展名通常为.yaml，如example.yaml。

> 注意，代码的排版有严格要求，缩进为2个字符！序列项的 - 后必须跟一个空格！：后也要跟一个空格！     

YAML语法要求如果值以\{\{ foo \}\}开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典.该知识点在 YAML 语法 页面有所讲述.
这样是不行的:
```
- hosts: app_servers

vars:

app_path: \{\{ base_path \}\}/22
```
应该这么做
```
- hosts: app_servers

vars:

app_path: "\{\{ base_path \}\}/22"
```

list列表的所有元素均使用“-”打头，例如：
```
#A list of tasty fruits
-Apple
-Orange
-Strawberry
-Mango
```

dictionary字典通过key与valuef进行标识，例如：
```
---

#An employee record

name:Example Developer
job:Developer
skill:Elite
```
也可以将key:value放置于\{\}中进行表示，例如：
```
---
#An employee record

{name:Example Developer, job: Developer, skill: Elite}
		 
```	 
# ansible inventory定义主机变量
编辑/etc/ansible/hosts
添加本机的public SSH key到目标机器的authorized_keys   #ssh-copy-id
添加本机的私钥到Ansible
运行
```
ansible all -m ping  # 测试是否添加成功
ansible -i hosts hostname -m ping # -i 指定hosts hostname指定组名或主机IP等

Inventory 分组
    Ansible可同时操作属于一个组的多台主机，组和主机之间的关系通过inventory文件配置，默认文件路径为/etc/ansible/hosts
 
常用参数配置：
    ansible_ssh_host                    # 目标主机地址
    ansible_ssh_port                    # 目标主机端口，默认22
    ansible_ssh_user                    # 目标主机用户
    ansible_ssh_pass                    # 目标主机ssh密码
    ansible_sudo_pass                 # sudo密码
    ansible_sudo_exe                    
    ansible_connection               # 与主机的连接类型，比如：local,ssh或者paramiko
    ansible_ssh_private_key_file  # 私钥地址
    ansible_shell_type                 # 目标系统的shell类型
    ansible_python_interpreter   # python版本
	
> 注意：上述配置参数都是ansible2.0版本以前的写法，2.0版本之后，应遵从如下写法     
ansible_ssh_port应该写成ansible_port
ansible_ssh_user应该写成ansible_user
ansible_ssh_host应该写成ansible_host	
 
格式：[组名] 
    例如 : 
    　　[test]   　　# 组名  
    　　10.0.0.1　 # 主机ip  或者10.0.0.1:65522 自定义端口
别名
    s1 ansible_ssh_port=65522 ansible_ssh_host=10.0.0.1 ansible_ssh_user=simon  　　# 别名s1
 
连续的主机
　　[g1]
       　　g[1:50].example.com
        　　g[a-f].example.com
 
```

```
[root@LeoDevops playb]# grep -vE "(^$|^#)" /etc/ansible/hosts 
192.168.93.132  key=132 key2=456
192.168.93.137  key=137
[nginx]
192.168.93.132
192.168.93.137
[nginx:vars]
ansible_python_interpreter=/usr/bin/python2.6
group_var="all node in this group can use this var"
```
注意：上面vars为固定的格式

# 组嵌套
inventory中，组还可以包含其它的组，并且也可以向组中的主机指定变量。不过，这些变量只能在ansible-playbook中使用，
而ansible不支持。
例如：
```
[apache]
httpd1.magedu.com
httpd2.magedu.com

[nginx]
ngx1.magedu.com
ngx2.magedu.com

[webservers:children]  children是固定格式，必须要写上的
apache
nginx

[webservers:vars]
ntp_server=ntp.magedu.com
```
 
写好palybook
```
[root@LeoDevops playb]# cat check_variable.yml 
- hosts: all
  gather_facts: False
  tasks:
    - name: Display Host Variable From Hostfile
      debug: msg="The { { inventory_hostname  } } Value is { { key  } }"
```
另一种方式，直接在playbook定义变量
```
[root@LeoDevops playb]# cat p_vars.yaml 
- hosts: all
  gather_facts: False  #设置为false,那么下面的debug模块会生效
  vars:       # 先申明vars这个关键字
    key: "Ansible"  #这种方式定义，key: value的形式
  tasks:
    - name: display host variables from hostfile
      debug: msg="The { { inventory_hostname  } } value is { { key } }"
```
或者在playbook里面引用有变量的文件
```
[root@LeoDevops playb]# cat p_vars.yaml
- hosts: all
  gather_facts: False
  vars_files:
    - var.json
  tasks:
    - name: display host variables from hostfile
      debug: msg="The { { inventory_hostname  } } value is { { key } }"
[root@LeoDevops playb]# cat var.json 
{"key":"json"}
```
通过命令行传输
通过-e参数能给将变量传入进去
```
[root@LeoDevops playb]# ansible-playbook check_variable.yml  -e "key=hehe"
[root@LeoDevops playb]# ansible-playbook test.yml --extra-vars "hosts=www user=mageedu"
[root@LeoDevops playb]# ansible-playbook test.yml --extra-vars "{'hosts':'vm-1', 'user':'root'}"

```
-e指定文件的方式传入变量
```
[root@LeoDevops playb]# cat var.json 
{"key":"json"}
[root@LeoDevops playb]# ansible-playbook check_variable.yml -e "@var.json"
```


# ansible--使用register变量
在ansible的playbook中task之间的相互传递变量
```
---
- hosts: test70
  remote_user: root
  tasks:
  - name: test shell
    shell: "echo test > /var/testshellfile"
    register: testvar
  - name: shell module return values
    debug:
      var: testvar
```
上例中共有两个任务，第一个任务使用shell模块在test70主机中创建了一个测试文件 /var/testshellfile，将字符"test"输入到了测试文件中，然后使用"register"关键字将当前shell任务的返回值写入了名为"testvar"的变量中，第二个任务使用debug模块输出了第一个任务中的注册变量的值，没错，注册变量就是这么简单，使用register关键字指定对应的变量名即可。


上述playbook执行后，可以在控制台中看到名为"[shell module return values]"的任务中已经显示了第一个任务的返回值的信息，返回信息如下


```
TASK [shell module return values] **********************************************************************
ok: [test70] => {
    "testvar": {
        "changed": true, 
        "cmd": "echo test > /var/testshellfile", 
        "delta": "0:00:00.003808", 
        "end": "2018-06-17 20:42:37.675382", 
        "failed": false, 
        "rc": 0, 
        "start": "2018-06-17 20:42:37.671574", 
        "stderr": "", 
        "stderr_lines": [], 
        "stdout": "", 
        "stdout_lines": []
    }
}

```
register.yml
```
---
- hosts: all
  gather_facts: no
  tasks:
    - name: register vars
      shell: hostname
      register: info
	  
    - name: display vars
      debug: msg="{ {info.stdout} }"
```

第一个shell执行完后，使用register获取数据到info里
> info是一个key value字典
debug输出info.stdout的具体内容

# 使用vars_prompt传入
ansible 还支持在运行playbook的时候通过交互式的方式给定义好的参数传入变量值，只需要在playbook中定义vars_prompt 的变量名和交互式提示内容即可。当然ansible还可以对传入的变量值进行加密处理。加密处理依赖于passlib python库。请看简单的 vars_prompt的例子
```
[root@LeoDevops playb]# cat p_prompt.yaml 
- hosts: all
  gather_facts: False
  vars_prompt:
    - name: "one"
      prompt: "please input your value"
      private: no
    - name: "two"
      prompt: "please input two value"
      default: 'good'  # 默认显示一个值
      private: yes  #置为yes的话，那么就是看不见自己输入的什么了
  tasks:
     - name: display one value
       debug: msg="one value is { { one } }"
     - name: display two value
       debug: msg="two value is { { two } }"
```
执行效果如下：
```
[root@LeoDevops playb]# ansible-playbook p_prompt.yaml 
please input your value: nihao
please input two value [good]:
```
ansible roles 在被引用时如何传递变量
覆盖或者新增roles的变量
```
---
- hosts: localhost
  remote_user: zhiming
  roles: 
  - common
  - {role: "test", vvvv_1: "ah" , test1: "this is test1", }
```  
# 变量
定义多个变量，示例如下。
```
vars:
  testvar1: testfile
  testvar2: testfile2
 
```
除了使用上述语法，使用YAML的块序列语法也可以定义变量，示例如下

```
vars:
  - testvar1: testfile
  - testvar2: testfile2
```

如上例所示，我定义了两个变量，两个变量的值对应两个nginx配置文件路径

```
  vars:
    nginx:
      conf80: /etc/nginx/conf.d/80.conf
      conf8080: /etc/nginx/conf.d/8080.conf
```
当我们需要引用这两个变量时，有两种语法可用

语法一

```
"{ {nginx.conf80} }"
```
语法二

```
"{ {nginx['conf8080']} }"
```
这样使用变量在逻辑上比较清晰，可以看出conf80与conf8080都属于nginx相关的配置。

> 当在playbook中为模块的参数赋值时，可以使用"冒号"，也可以使用"等号"，当使用"等号"为模块的参数赋值时，则不用考虑引用变量时是否使用"引号"的问题    

示例如下
```


---
- hosts: test70
  remote_user: root
  vars:
    nginx:
      conf80: /etc/nginx/conf.d/80.conf
      conf8080: /etc/nginx/conf.d/8080.conf
  tasks:
  - name: task1
    file:
      path={ {nginx.conf80} }
      state=touch
  - name: task2
    file:
      path={ {nginx['conf8080']} }
      state=touch
 
 ```

把变量定义在文件,playbook中定义变量的几种语法相同
```
cat nginx_vars.yml
语法一示例：
  testvar1: testfile
  testvar2: testfile2
语法二示例：
  - testvar1: testfile
  - testvar2: testfile2
语法三示例：
nginx:
  conf80: /etc/nginx/conf.d/80.conf
  conf8080: /etc/nginx/conf.d/8080.conf
 
 ```
每个被引入的文件都需要以"- "开头，示例如下
```
  vars_files:
    - /testdir/ansible/nginx_vars.yml
    - /testdir/ansible/other_vars.yml
```

"vars"关键字和"vars_files"关键字可以同时使用，如下
```
  vars:
    - conf90: /etc/nginx/conf.d/90.conf
  vars_files:
    - /testdir/ansible/nginx_vars.yml
```
通过set_fact定义变量
```
set_fact是一个模块，我们可以通过set_fact模块在tasks中定义变量，先来看一个小示例，如下
```
---
- hosts: test70
  remote_user: root
  tasks:
  - set_fact:
      testvar: "testtest"
  - debug:
      msg: "{ {testvar} }"
```
如上例所示，我们通过set_fact模块定义了一个名为testvar的变量，变量值为testtest，

内置变量
```
ansible_version
inventory_hostname #hosts配置文件内得主机名
hostvars  # 获取主机变量
play_hosts #当前play所操作的所有主机的主机名列表
groups #清单中"所有分组"
group_names#当前主机所在分组的组名
inventory_dir#ansible主机中清单文件的存放路径
```

# 迭代
当有需要重复性执行的任务时，可以使用迭代机制。其使用格式为将需要迭代的内容定义为item变量引用，并通过with_items语句来指明迭代的元素列表即可。例如：
```
- name: add several users
  user: name={ { item } } state=present groups=wheel
  with_items:
        - testuser1
        - testuser2
```
上面语句的功能等同于下面的语句：
```
- name: add user testuser1
  user: name=testuser1 state=present groups=wheel
- name: add user testuser2
  user: name=testuser2 state=present groups=wheel
```
另外，with_items中使用的元素还可以是hashes，例如：
```
- name: add several users
  user: name={ { item.name } } state=present groups={ { item.groups } }
  with_items:
        - { name: 'testuser1', groups: 'wheel'}
        - { name: 'testuser2', groups: 'root'}
```
【注意】：item是固定变量名。

# 使用Facts获取的信息
Facts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的:
```
ansible hostname -m setup
ansible test70 -m setup -a 'filter=ansible_memory_mb'
 
```
可以在playbook中这样引用以上例子中第一个硬盘的模型:
```
{ { ansible_devices.sda.model } }
```
同样,作为系统报告的主机名如以下所示:
```
{ { ansible_nodename } }
```
不合格的主机名显示了句号(.)之前的字符串:
```
{ { ansible_hostname } }
```
在模板和条件判断(请看 playbook_conditionals )中会经常使用Facts.

## 关闭Facts
```
- hosts: whatever

gather_facts: no
```
另外 ，关闭了facts，ansible执行的速度会快很多	 
		 
编辑ansible的hosts文件
```
vi /etc/ansible/hosts  #在这里面加入你要控制的机器ip
```


# handlers
在notify中列出的操作称为handler，也即notify中调用handler中定义的操作。
```
- name: template configuration file
        template: src=template.j2 dest=/etc/foo.conf
        notify:
            - restart memcached
            - restart apache    
```
handler是task列表，这些task与前述的task并没有本质上的不同。
```
handlers:
        - name: restart memcached
		  service: name=memcached state=restarted
		
		- name: restart apache
		  service: name=apache state=restarted
```

例： heartbeat.yaml
```
- hosts: hbhosts
  remote_user: root
  tasks:
		- name: ensure heartbeat latest version
		  yum: name=heartbeat state=present
		
		- name: authkeys configure file
		  copy: src=/root/hb_conf/authkeys dest=/etc/ha.d/authkeys
		
		- name: authkeys mode 600
		  file: path=/etc/ha.d/authkeys mode=600
		  notify:
				- restart heartbeat
		- name: ha.cf configure file
		  copy: src=/root/hb_conf/ha.cf dest=/etc/ha.d/ha.cf
		  notify:
			- restart heartbeat

		handlers:
			- name:restart heartbeat
			  service: name=heartbeat state=restarted
```				  
例子1：
```
---
- hosts: test70
  remote_user: root
  tasks:
  - name: make testfile1
    file: path=/testdir/testfile1
          state=directory
    notify: ht2
  - name: make testfile2
    file: path=/testdir/testfile2
          state=directory
    notify: ht1
 
  handlers:
  - name: ht1
    file: path=/testdir/ht1
          state=touch
  - name: ht2
    file: path=/testdir/ht2
          state=touch
```
默认情况下，所有task执行完毕后，才会执行各个handler，并不是执行完某个task后，立即执行对应的handler，如果你想要在执行完某些task以后立即执行对应的handler，则需要使用meta模块，示例如下
```
---
- hosts: test70
  remote_user: root
  tasks:
  - name: task1
    file: path=/testdir/testfile
          state=touch
    notify: handler1
  - name: task2
    file: path=/testdir/testfile2
          state=touch
    notify: handler2
 
  - meta: flush_handlers
 
  - name: task3
    file: path=/testdir/testfile3
          state=touch
    notify: handler3
 
  handlers:
  - name: handler1
    file: path=/testdir/ht1
          state=touch
  - name: handler2
    file: path=/testdir/ht2
          state=touch
  - name: handler3
    file: path=/testdir/ht3
          state=touch
```
一个task中一次性定义多个notify用关键字listen，可以理解为组
如下task执行的是handler1 和handler2 ，
```
---
- hosts: test70
  remote_user: root
  tasks:
  - name: task1
    file: path=/testdir/testfile
          state=touch
    notify: handler group1
 
  handlers:
  - name: handler1
    listen: handler group1
    file: path=/testdir/ht1
          state=touch
  - name: handler2
    listen: handler group1
    file: path=/testdir/ht2
          state=touch
```
# roles
```
ansible_home/
├── main.yml
└── roles
    ├── common
    │   ├── defaults
    │   ├── files
    │   ├── handlers
    │   ├── meta
    │   ├── tasks
    │   ├── templates
    │   └── vars
    ├── dbservers
    │   ├── defaults
    │   ├── files
    │   ├── handlers
    │   ├── meta
    │   ├── tasks
    │   ├── templates
    │   └── vars
    └── webservers
        ├── defaults
        ├── files
        ├── handlers
        ├── meta
        ├── tasks
        │   ├── apache_conf.yml
        │   ├── apache_vhost_conf.yml
        │   └── main.yml
        ├── templates
        │   ├── apache_conf.j2
        │   └── apache_vhost.conf.j2
        └── vars
            └── main.yml
```
a）创建role的步骤
(1) 创建以roles命名的目录；
(2) 在roles目录中分别创建以各角色名称命名的目录，如webservers等；
(3) 在每个角色命名的目录中分别创建files、handlers、meta、tasks、templates和vars目录；用不到的目录可以创建为空目录，也可以不创建；
(4) 在playbook文件中，调用各角色；

b） role内各目录中可用的文件
tasks目录：至少应该包含一个名为main.yml的文件，其定义了此角色的任务列表；此文件可以使用include包含其它的位于此目录中的task文件；
files目录：存放由copy或script等模块调用的文件；
templates目录：template模块会自动在此目录中寻找Jinja2模板文件；
handlers目录：此目录中应当包含一个main.yml文件，用于定义此角色用到的各handler；在handler中使用include包含的其它的handler文件也应该位于此目录中；
vars目录：应当包含一个main.yml文件，用于定义此角色用到的变量；
meta目录：应当包含一个main.yml文件，用于定义此角色的特殊设定及其依赖关系；ansible 1.3及其以后的版本才支持；
default目录：为当前角色设定默认变量时使用此目录；应当包含一个main.yml文件；

c） roles使用案例
1.建立相应目录
```
ansible_playbooks/roles/{websrvs,dbsrvs}/{tasks,files,templates,meta,handlers,vars}
```
2.解决第一个角色websrvs
先把要用到的配置文件拷过来（待会要复制给各个服务器使用的）
```
cp/etc/httpd/conf/httpd.conf /ansible_playbooks/roles/websrvs/files 
```
3.定义任务tasks  vim/ansible_playbooks/roles/websrvs/tasks/main.yml
内容：
```
   - name: install httpd package
     yum: name=httpd
   - name:install configuration file
     copy: src=httpd.conf dest=/etc/httpd/conf/httpd.conf  #注意路径，都可以使用相对路径直接调用
     tags:
        - conf
     notify:
        - restart httpd
   - name: start httpd
     service: name=httpd state=started
```
4.由于tasks中使用了notify,即需要另外定义handler，所以必须在/ansible_playbooks/roles/websrvs/handlers编写
添加main.yml文件
内容如下：
```
   - name: restart httpd
     service: name=httpd state=restarted
```

5.如果没有其他内容了就可以了，有的话继续在相应的目录下建立main.yml定义
假如又使用了变量，就要在vars下定义一个main.yml指定变量
```
   - httpd_port: 80
   - maxClients: 180
```
6.创建/ansible_playbooks/site.yml  指定创建了的角色
```
- hosts: websrvs
  remote_user: root
  roles:
       - websrvs
```
至此roles创建完成，要想把相应的角色用在某个主机上的话，直接在site.yml上- hosts:websrvs 指定，roles下设置对应角色即可。
这样：
```
- hosts: websrvs
  remote_user: root
  roles:
        - websrvs

- hosts: websrvs2
  remote_user: root
  roles:
        - websrvs2
        - dbsrvs
```
最后执行ansible-playbooks site.yml
> 注意：复制到相应目录的文件，都可以直接写文件名调用    

   
在playbook中，可以这样使用roles（调用common和webservers角色了）：
```
---
   - hosts: webservers
     roles:
        - common
        - webservers
```

也可以向roles传递参数，例如：
```
---
   - hosts: webservers
     roles:
        - common
        - { role: foo_app_instance, dir:'/opt/a',  port: 5000 }
        - { role: foo_app_instance, dir:'/opt/b',  port: 5001 }
```

甚至也可以条件式地使用roles，例如：
```
---
    - hosts: webservers
      roles:
          - { role: some_role, when:"ansible_os_family == 'RedHat'" }
```


# Tags
例子1：
apache.yml内容：
```
- hosts: websrvs
  remote_user: root
  vars:
    - package: httpd
    - service: httpd
  tasks:
    - name: install httpd package
      yum: name=` package ` state=latest
    - name: install configuration file for httpd
      template: src=/root/templates/httpd.conf.j2dest=/etc/httpd/conf/httpd.conf
      tags:
        - conf
      notify:
        - restart httpd
    
	- name: start httpd service
      service: enabled=true name=` service ` state=started
      handlers:
         - name:restart httpd
           service: name=httpd state=restarted
```
调用：
```
ansible-playbook apache.yml --tags="conf"，
```
这样只执行了
```
- name: install configuration file for httpd
  template: src=/root/templates/httpd.conf.j2dest=/etc/httpd/conf/httpd.conf
  tags:
     - conf
```

例子2：
```
---
- hosts: test70
  remote_user: root
  tasks:
  - name: task1
    file:
      path: /testdir/t1
      state: touch
    tags: t1

  - name: task2
    file: path=/testdir/t2
          state=touch
    tags: t2

  - name: task3
    file: path=/testdir/t3
          state=touch
    tags: t3
```

ansible-playbook --tags=t2 testtag.yml
ansible-playbook --skip-tags='t2' testtag.yml

tags其他语法：
```
---
- hosts: test70
  remote_user: root
  tasks: 
  - name: task1
    file: 
      path: /testdir/t1
      state: touch
    tags:
      - t1
  - name: task2
    file: path=/testdir/t2
          state=touch
    tags: ['t2']

```
定义多个tags
语法一：
tags:
 - testtag
 - t1
 
语法二：
tags: tag1,t1
 
语法三：
tags: ['tagtest','t2']

不同任务可以使用相同的tags
```
---
- hosts: test70
  remote_user: root
  tasks:
  - name: install httpd package
    tags: httpd,package
    yum:
      name=httpd
      state=latest
 
  - name: start up httpd service
    tags: httpd,service
    service:
      name: httpd
      state: started
```
tasks中相同的tags可以写到play中,这样所有play下的task会继承当前play中的tags
```
---
- hosts: test70
  remote_user: root
  tags: httpd
  tasks:
  - name: install httpd package
    tags: ['package']
    yum:
      name=httpd
      state=latest
 
  - name: start up httpd service
    tags:
      - service
    service:
      name: httpd
      state: started
```

一次性调用多个tags
```
ansible-playbook --tags package,service testhttpd.yml
```
查看playbook中的标签
```
ansible-playbook --list-tags testhttpd.yml
```

5个预置的特殊tag
always
never(2.5版本新加入,与always相反)
tagged
untagged
all

当我们把任务的tags的值指定为always时，那么这个任务就总是会被执行，除非你使用'--skip-tags'选项明确指定不执行对应的任务
示例如下
```
---
- hosts: test70
  remote_user: root
  tasks:
  - name: task1
    file:
      path: /testdir/t1
      state: touch
    tags:
      - t1

  - name: task2
    file: path=/testdir/t2
          state=touch
    tags: ['t2']

  - name: task3
    file: path=/testdir/t3
          state=touch
    tags: t3,always
```
只指定了't1'，正常情况下应该只执行't1'对应的任务，也就是应该只执行task1，但是实际上执行了task1和task3，这是因为task3的标签的值包含always关键字，所以即使task3对应的标签没有被调用，task3也会执行，这就是always的作用。
```
ansible-playbook --tags t1 testhttpd.yml
```
跳过always标签
```
ansible-playbook --skip-tags always testtag.yml
```
但是需要注意，如果上述play中有多个任务都有always标签，那么上述命令将会跳过所有包含always标签的任务

剩余的三个特殊标签分别为 tagged、untagged、all
这三个特殊标签并非像always一样，always作为标签值存在，而这三个特殊标签则是在调用标签时使用，示例如下
```
ansible-playbook --tags tagged testtag.yml
ansible-playbook --skip-tags tagged testtag.yml   # 跳过包含标签的任务，即使对应的任务包含always标签，也会被跳过。

ansible-playbook --tags untagged testtag.yml      # 只执行没有标签的任务，但是如果某些任务包含always标签，那么这些任务也会被执行。
ansible-playbook --skip-tags untagged testtag.yml # 跳过没有标签的任务。

```
特殊标签all表示所有任务会被执行，不用指定，默认情况下就是使用这个标签。




















```

配置主机别名
test_alias ansible_host=10.1.1.60 

使用别名字
ansible test_alias -m ping 
注意如果只使用了别名,则无法通过主机的ip进行管理,除非同时使用ip和别名的方式配置两个主机条目


ansible_ssh_private_key_file参数，指定连接对应主机时所使用的私钥

inventory配置组
```
10.1.1.50

[proA]
10.1.1.60

[proB]
10.1.1.70

[pro:children]
proA
proB
10.1.1.50

```
注意:children为固定写法


根据返回的颜色判断是否changed
如:
当ansible进行fetch操作时，会对对应文件进行哈希计算，算出文件哈希值，也就是说，如果我们改变了文件中的内容，哈希值也将随之发生改变，这个时候，即使对应目录中存在同名的文件，ansible也会判断出两个文件属于不同的文件
```
ansible testA -m fetch -a "src=/etc/fstab dest=/testdir/ansible/"  # 返回颜色为黄色,changed为true
ansible testA -m fetch -a "src=/etc/fstab dest=/testdir/ansible/"  # 返回颜色为绿色,changed为false
#修改文件/etc/fstab之后在执行
ansible testA -m fetch -a "src=/etc/fstab dest=/testdir/ansible/"  # 返回颜色为黄色,changed为true
```
src参数，src参数的作用就是指定从受管主机中拉取哪个文件(暂时只支持文件,不支持目录)。
dest参数，dest参数的作用就是指定拉取文件到本地以后文件存放的位置(目录)。
假设dest是目录/backup,src=/etc/profile从host.example.com拉取文件则最终会保存成/backup/host.example.com/etc/profile

```

