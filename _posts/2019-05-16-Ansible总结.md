---
layout:     post
title:      Ansible总结
date:       2019-05-18
author:     BenderFly
header-img: img/post-bg-coffee.jpeg
catalog: true
categories: 运维
tags:
    - Ansible
    - 运维
---

# Ansible总结

安装ansible
```
wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
yum install -y ansible
```
查看ansible生成的文件
```
rpm -ql ansible|more
```

配置ssh免密码登录
```
ssh-keygen
ssh-copy-id 192.168.107.131 # 复制秘钥到远程主机
```
# 查看帮助文档
```
# ansible-doc -h 
ansible-doc -s module-name # 查看模块使用方法(显示片段)
ansible-doc module-name    # 查看模块使用方法(更具体)
```

# ansible命令参数
语法: ansible<host-pattern> [-f forks] [-m module_name] [-a args] 
```
ansible -h     命令格式查看

-v,–verbose    			 			# 细模式，如果命令执行成功，输出详细的结果 (-vv –vvv -vvvv)
-i PATH,–inventory=PATH  			# 指定 host 文件的路径，默认是在 /etc/ansible/hosts
-f NUM,–forks=NUM 		 			# NUM 是指定一个整数，默认是 5 ，指定 fork 开启同步进程的个数。用来做高并发的
-m NAME,–module-name=NAME			# 指定使用的 module 名称，默认是 command
-m DIRECTORY,–module-path=DIRECTORY # 指定 module 的目录来加载 module ，默认是/usr/share/ansible,
-a MODULE_ARGS, --args=MODULE_ARGS  # 指定 module 模块的参数
-k,–ask-pass						# 提示输入 ssh 的密码，而不是使用基于 ssh 的密钥认证
–sudo								# 指定使用 sudo 获得 root 权限
-K,–ask-sudo-pass   				# 提示输入 sudo 密码，与 –sudo 一起使用
-u USERNAME,–user=USERNAME  		# 指定移动端的执行用户
-C,–check                           # 测试此命令执行会改变什么内容，不会真正的去执行
--list-hosts #列出主机列表
--syntax-check # 语法检查
```


# YAML基本语法
YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用"-"来代表，Map里的键值对用":"分隔。

YAML文件扩展名通常为.yaml，如example.yaml。

> 注意，代码的排版有严格要求，缩进为2个字符！序列项的 - 后必须跟一个空格！：后也要跟一个空格！     

YAML语法要求如果值以{{ foo }}开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典.该知识点在 YAML 语法 页面有所讲述.
这样是不行的:
```
- hosts: app_servers

vars:

app_path: {{ base_path }}/22
```
应该这么做
```
- hosts: app_servers

vars:

app_path: "{{ base_path }}/22"
```

list列表的所有元素均使用“-”打头，例如：
```
#A list of tasty fruits
-Apple
-Orange
-Strawberry
-Mango
```

dictionary字典通过key与valuef进行标识，例如：
```
---

#An employee record

name:Example Developer
job:Developer
skill:Elite
```
也可以将key:value放置于{}中进行表示，例如：
```
---
#An employee record

{name:Example Developer, job: Developer, skill: Elite}
		 
```	 
# ansible inventory定义变量
```
[root@LeoDevops playb]# grep -vE "(^$|^#)" /etc/ansible/hosts 
192.168.93.132  key=132
192.168.93.137  key=137
[nginx]
192.168.93.132
192.168.93.137
[nginx:vars]
ansible_python_interpreter=/usr/bin/python2.6
```
写好palybook
```
[root@LeoDevops playb]# cat check_variable.yml 
- hosts: all
  gather_facts: False
  tasks:
    - name: Display Host Variable From Hostfile
      debug: msg="The {{ inventory_hostname  }} Value is {{ key  }}"
```
另一种方式，直接在playbook定义变量
```
[root@LeoDevops playb]# cat p_vars.yaml 
- hosts: all
  gather_facts: False  #设置为false,那么下面的debug模块会生效
  vars:       # 先申明vars这个关键字
    key: "Ansible"  #这种方式定义，key: value的形式
  tasks:
    - name: display host variables from hostfile
      debug: msg="The {{ inventory_hostname  }} value is {{ key }}"
```
或者在playbook里面引用有变量的文件
```
[root@LeoDevops playb]# cat p_vars.yaml
- hosts: all
  gather_facts: False
  vars_files:
    - var.json
  tasks:
    - name: display host variables from hostfile
      debug: msg="The {{ inventory_hostname  }} value is {{ key }}"
[root@LeoDevops playb]# cat var.json 
{"key":"json"}
```
通过命令行传输
通过-e参数能给将变量传入进去
```
[root@LeoDevops playb]# ansible-playbook check_variable.yml  -e "key=hehe"
```
-e指定文件的方式传入变量
```
[root@LeoDevops playb]# cat var.json 
{"key":"json"}
[root@LeoDevops playb]# ansible-playbook check_variable.yml -e "@var.json"
```


# ansible--使用register变量
在ansible的playbook中task之间的相互传递变量
register.yml
```
---
- hosts: all
  gather_facts: no
  tasks:
    - name: register vars
      shell: hostname
      register: info
	  
    - name: display vars
      debug: msg="{{info.stdout}}"
```

第一个shell执行完后，使用register获取数据到info里
> info是一个key value字典
debug输出info.stdout的具体内容

# 使用vars_prompt传入
ansible 还支持在运行playbook的时候通过交互式的方式给定义好的参数传入变量值，只需要在playbook中定义vars_prompt 的变量名和交互式提示内容即可。当然ansible还可以对传入的变量值进行加密处理。加密处理依赖于passlib python库。请看简单的 vars_prompt的例子
```
[root@LeoDevops playb]# cat p_prompt.yaml 
- hosts: all
  gather_facts: False
  vars_prompt:
    - name: "one"
      prompt: "please input your value"
      private: no
    - name: "two"
      prompt: "please input two value"
      default: 'good'  # 默认显示一个值
      private: yes  #置为yes的话，那么就是看不见自己输入的什么了
  tasks:
     - name: display one value
       debug: msg="one value is {{ one }}"
     - name: display two value
       debug: msg="two value is {{ two }}"
```
执行效果如下：
```
[root@LeoDevops playb]# ansible-playbook p_prompt.yaml 
please input your value: nihao
please input two value [good]:
```
ansible roles 在被引用时如何传递变量
```
ansible_home/
├── main.yml
└── roles
    ├── common
    │   ├── defaults
    │   ├── files
    │   ├── handlers
    │   ├── meta
    │   ├── tasks
    │   ├── templates
    │   └── vars
    ├── dbservers
    │   ├── defaults
    │   ├── files
    │   ├── handlers
    │   ├── meta
    │   ├── tasks
    │   ├── templates
    │   └── vars
    └── webservers
        ├── defaults
        ├── files
        ├── handlers
        ├── meta
        ├── tasks
        │   ├── apache_conf.yml
        │   ├── apache_vhost_conf.yml
        │   └── main.yml
        ├── templates
        │   ├── apache_conf.j2
        │   └── apache_vhost.conf.j2
        └── vars
            └── main.yml
```

覆盖或者新增roles的变量
```
---
- hosts: localhost
  remote_user: zhiming
  roles: 
  - {role: "test", vvvv_1: "ah" , test1: "this is test1", }
```  
  
  
# 使用Facts获取的信息
Facts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的:
```
ansible hostname -m setup
```
可以在playbook中这样引用以上例子中第一个硬盘的模型:
```
{{ ansible_devices.sda.model }}
```
同样,作为系统报告的主机名如以下所示:
```
{{ ansible_nodename }}
```
不合格的主机名显示了句号(.)之前的字符串:
```
{{ ansible_hostname }}
```
在模板和条件判断(请看 playbook_conditionals )中会经常使用Facts.

## 关闭Facts
```
- hosts: whatever

gather_facts: no
```
另外 ，关闭了facts，ansible执行的速度会快很多	 
		 
编辑ansible的hosts文件
```
vi /etc/ansible/hosts  #在这里面加入你要控制的机器ip
```

ansible 192.168.115.134 -m ping